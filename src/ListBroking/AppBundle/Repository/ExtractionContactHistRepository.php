<?php

namespace ListBroking\AppBundle\Repository;

use Doctrine\ORM\AbstractQuery;
use Doctrine\ORM\EntityRepository;
use ListBroking\AppBundle\Entity\ContactHist;
use ListBroking\AppBundle\Entity\LeadHist;

/**
 * ExtractionContactHistRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ExtractionContactHistRepository extends EntityRepository implements ExtractionContactHistRepositoryInterface
{
    /**
     * Gets a Summary of Extraction Contacts Hist
     *
     * @param Extraction $extraction
     *
     * @return mixed
     */
    public function findExtractionSummary (Extraction $extraction)
    {
        $qb = $this->createQueryBuilder('ech')
                   ->select('o.name, count(o.name) as total')
                   ->join('ech.contact_hist', 'ch')
                   ->join('ch.owner', 'o')
                   ->where('ech.extraction = :extraction')
                   ->setParameter('extraction', $extraction->getId())
                   ->groupBy('ch.owner')
        ;

        return $qb->getQuery()
                  ->execute(null, Query::HYDRATE_ARRAY)
            ;
    }

    /**
     * Gets the Extraction Contacts Hist of a given Extraction
     *
     * @param Extraction $extraction
     * @param null       $limit
     * @param            $hydrationMethod
     *
     * @return mixed
     */
    public function findExtractionContacts (Extraction $extraction, $limit = null, $hydrationMethod = AbstractQuery::HYDRATE_OBJECT)
    {

        return $this->findExtractionContactsQuery($extraction, $limit)
                    ->execute(null, $hydrationMethod)
            ;
    }

    /**
     * Counts the Extraction Contacts of a given Extraction
     *
     * @param Extraction $extraction
     *
     * @return int
     * @throws \Doctrine\ORM\NoResultException
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function countExtractionContacts(Extraction $extraction)
    {
        return (int) $this->createQueryBuilder('ech')
                          ->select('count(ech.id)')
                          ->where('ech.extraction = :extraction')
                          ->setParameter('extraction', $extraction->getId())
                          ->getQuery()
                          ->getSingleScalarResult()
            ;
    }

    /**
     * Gets a Query object of the Extraction Contacts
     *
     * @param Extraction $extraction
     * @param null       $limit
     * @param null       $fetch_mode
     *
     * @return Query
     */
    public function findExtractionContactsQuery (Extraction $extraction, $limit = null, $fetch_mode = null)
    {
        $qb = $this->createQueryBuilder('ech')
                   ->join('ech.contact_hist', 'ch')
                   ->where('ech.extraction = :extraction')
                   ->setParameter('extraction', $extraction->getId())
        ;

        // Add Limit
        if ( $limit )
        {
            $qb->setMaxResults($limit);
        }
        $query = $qb->getQuery();

        switch ($fetch_mode)
        {
            case ClassMetadata::FETCH_EAGER:

                foreach ( $this->getClassMetadata()->getAssociationMappings() as $mapping )
                {
                    $query->setFetchMode($this->getClassName(), $mapping['fieldName'], ClassMetadata::FETCH_EAGER);
                }
                break;
            default:
                break;
        }

        return $query;
    }

    /**
     * Finds extraction contacts hist of a given extraction with a limit and an ID offset
     *
     * @param Extraction $extraction
     * @param            $headers
     * @param            $limit
     * @param            $offset
     *
     * @return array
     * @throws \Doctrine\DBAL\DBALException
     */
    public function findExtractionContactsWithIdOffset(Extraction $extraction, $headers, $limit, $offset)
    {
        $conn = $this->getEntityManager()
                     ->getConnection()
        ;

        $parameters = array(
            'extraction_id' => $extraction->getId(),
            'offset' => $offset
        );

        $composed_headers = $this->composeHeaders($headers);
        $find_extraciton_contacts_query = <<<SQL
            SELECT extraction_contact_hist.id as extraction_contact_id, {$composed_headers}
            FROM extraction_contact_hist extraction_contact_hist
            LEFT JOIN contact_hist contact_hist ON contact_hist.id = extraction_contact_hist.contact_id
            LEFT JOIN lead_hist lead_hist ON lead_hist.id = contact_hist.lead_id
            LEFT JOIN source source ON source.id = contact_hist.source_id
            LEFT JOIN owner owner ON owner.id = contact_hist.owner_id
            JOIN sub_category sub_category ON sub_category.id = contact_hist.sub_category_id
            LEFT JOIN category category ON category.id = sub_category.category_id
            JOIN gender gender ON gender.id = contact_hist.gender_id
            LEFT JOIN district district ON district.id = contact_hist.district_id
            LEFT JOIN county county ON county.id = contact_hist.county_id
            LEFT JOIN parish parish ON parish.id = contact_hist.parish_id
            JOIN country country ON country.id = contact_hist.country_id
            WHERE extraction_contact_hist.extraction_id = :extraction_id
            AND extraction_contact_hist.id > :offset
            ORDER BY extraction_contact_hist.id ASC
            LIMIT $limit
            ;
SQL;
        $statment = $conn->prepare($find_extraciton_contacts_query);
        $statment->execute($parameters);

        return $statment->fetchAll();
    }

    private function composeHeaders($headers){
        $composed_headers = array();
        foreach ($headers as $label => $field)
        {
            $composed_headers[] =  sprintf('%s as "%s"', $field, $label);
        }

        return implode(",", $composed_headers);
    }

    /**
     * Cleanup records from $maxExtractionId or older.
     * @param $maxExtractionId
     * @return mixed
     */
    public function cleanUp($maxExtractionId)
    {
        return $this->createQueryBuilder('ech')
                    ->delete('ListBrokingAppBundle:ExtractionContactHist' ,'ech')
                    ->where('ech.extraction_id <= :extraction')
                    ->setParameter('extraction', $maxExtractionId)
                    ->getQuery()
                    ->execute();
    }

    /**
     * {@inheritdoc}
     */
    public function findContactExtractions(ContactHist $contactHist): array
    {
        return $this->createQueryBuilder('ech')
                    ->select('co.date, e.name AS name, e.sold_at, ca.name AS campaign')
                    ->innerJoin('ech.extraction', 'e')
                    ->innerJoin('e.campaign', 'ca')
                    ->innerJoin('ech.contact_hist', 'co')
                    ->where('ech.contact_hist = :contactId')
                    ->setParameter('contactId', $contactHist->getId())
                    ->getQuery()
                    ->execute(null, Query::HYDRATE_ARRAY);
    }

    /**
     * {@inheritdoc}
     */
    public function getLeadCampaignsGroupByClient(LeadHist $leadHist): array
    {
        $selectStatement = <<<SQL
  cl.id as client_id,
  lh.phone as phone,
  group_concat(ch.email) as emails,
  group_concat(ca.id) as campaigns_ids,
  group_concat(
    concat(ca.name, ' (Sold at: ', date(e.sold_at), ')')
  ) as campaigns_names
SQL;

        return $this->createQueryBuilder('ech')
                    ->select($selectStatement)
                    ->innerJoin('ech.extraction', 'e')
                    ->innerJoin('e.campaign', 'ca')
                    ->innerJoin('ca.client', 'cl')
                    ->innerJoin('ech.contact_hist', 'ch')
                    ->innerJoin('ch.lead_hist', 'lh')
                    ->where('lh.id = (:leadId)')
                    ->andWhere('e.sold_at is not null')
                    ->groupBy('cl.id')
                    ->setParameter('leadId', $leadHist->getId())
                    ->getQuery()
                    ->execute(null, Query::HYDRATE_ARRAY);
    }

    /**
     * {@inheritdoc}
     */
    public function getExtractionContactsSoldByLead(LeadHist $leadHist, bool $sold): array
    {
        $qb = $this->createQueryBuilder('ech')
                   ->addSelect(['e', 'ca'])
                   ->innerJoin('ech.extraction', 'e')
                   ->innerJoin('e.campaign', 'ca')
                   ->innerJoin('ech.contact_hist', 'ch')
                   ->innerJoin('ch.lead_hist', 'lh')
                   ->where('lh.id = (:leadId)');

        if ($sold) {
            $qb->andWhere('e.sold_at is not null');
        }

        return $qb->setParameter('leadId', $leadHist->getId())
                  ->getQuery()
                  ->execute();
    }
}
